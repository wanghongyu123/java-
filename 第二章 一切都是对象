1. 用引用操控对象：
      每种编程语言都有自己的数据操纵方式，例如：C和C++里的指针来操纵对象。在Java里一切都被视为对象，尽管一切都看作对象，但操作的标识符实际上是对象的一个“引用”。
   因此，如果想操纵一个词或句子，则可以创建一个String引用：String s; 但这里所创建的只是引用，并不是对象，如果此时向s发送一个消息，就会返回一个运行时错误。这是
   因为此时s实际上没有与任何事物相关联（即，没有真正一个词或句子），因此，一种安全的做法是：创建一个引用的同时进行初始化。 String s = "asdf";
2. 必须由你创建所有对象：
      一旦创建了一个引用，就希望它能与一个新的对象相关联，通常用new关键字来实现这一目的。例如：String s = new String("asdf");
   2.1 存储到什么地方：有六个不同的地方存储数据
      1）寄存器。这是最快的存储区，因为它位于不同于其他存储去的地方——处理器内部，但是寄存器的数量及其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也
      不能在程序中感觉到寄存器存在的任何迹象。
      2）堆栈。位于通用RAM（随机访问存储器）中，但通过 “堆栈指针” 可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内
      存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下
      移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。
      3）堆。一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存
      活多长时间。因此，在堆里分配存储有很大的灵活性。当需要创建一个对象时，只需要new写 一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵
      活性必须要付出相应的代价。用堆进行存储分配比用堆栈进行存储分配需要更多的时间。    
      4）静态存储。这里的 “静态” 是指 “在固定的位置”（尽管也在RAM里）。静态存储里存放程序运行时一直存在的数据。可用关键字static来标识某个对象的特定元素是静态的，
      但Java对象本身从来不会存放在静态存储空间里。
      5）常量存储。常量值通常直接存放在程序代码内部，这样做是安全的，因为他们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分隔离开所以在这种情况下，可
      以选择将其存放在ROM（只读存储器）中。
      6）非RAM存储。如果数据完全存活于程序之外，那么他可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是 “流对象” 和 “持久化对象”。在流对象
      中，对象转化成字节流，通常被发送给另一台机器。在 “持久化对象” 中，对象被存放于磁盘上，因此，即使程序终止，他们仍可以保持自己的状态。这种存储方式的技巧在于：
      把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的，基于RAM的对象。Java提供对轻量级持久化的支持。
   2.2 特例：基本类型：
         “基本” 类型之所以特殊对待，是因为new将对象存储在 “堆” 里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采取与C和C++
      相同的方法。也就是说，不用new来创建变量，而是创建一个并非是 “引用” 的 “自动” 变量。这个变量拥有 “值”，并置于堆栈中，因此更加有效。
          Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序具有可移植性的
      原因之一。  
                    基本类型      大小       最小值        最大值           包装器类型
                    boolean       —         —            —               Boolean
                    char        16-bit     Unicode 0    Unicode 2^16-1   Character
                    byte        8-bit      -128         +127             Byte
                    short       16-bit     -2^15        +2^15-1          Short
                    int         32-bit     -2^31        +2^31-1          Integer
                    long        64-bit     -2^63        +2^63-1          Long
                    float       32-bit     IEEE754      IEEE754          Float
                    double      64-bit     IEEE754      IEEE754          Double
      所有数值类型都有正负号，所以不要去寻找无符号的数值类型。
          Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于 “包装器类” 的范畴，但二者没有对应的基本类型。不过，这两个类包含的方法，提供的
      操作与对基本类型所执行的操作相似。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。这这里，我们以速度换取了精度。
          BigInteger支持任意精度的整数，也就是说，在运算中，可以准确的表示任何大小的整数值，而不会丢失任何信息。
          BigDecimal支持任何精度的定点数，例如，可以用它进行精度的货币计算。
       
